// 2) Fallback for non-web contexts (Kafka worker, etc.)
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(SecurityFilterChain.class)
public class NoWebSecurityConfig {
  // Nothing to secure; just prevent Spring Security from trying to create a servlet chain.
  @Bean
  WebSecurityCustomizer noopCustomizer() {
    return web -> {};
  }
}

// 1) Servlet security (only created when a Servlet web app is present)
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@EnableMethodSecurity
public class ServletSecurityConfig {

  private final Environment env;
  private final AdfsConfigurer<HttpSecurity> adfsConfigurer; // keep it optional if needed

  public ServletSecurityConfig(Environment env,
      @Autowired(required = false) AdfsConfigurer<HttpSecurity> adfsConfigurer) {
    this.env = env;
    this.adfsConfigurer = adfsConfigurer;
  }

  @Bean
  SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    // if you keep requiresChannel(), this will only run when ServletContext exists
    if (!env.acceptsProfiles(Profiles.of("local","dev","local-h2-enabled","contract-test"))) {
      http.requiresChannel(c -> c.anyRequest().requiresSecure());
    }

    // do NOT use EndpointRequest unless you are sure actuator servlet endpoints are present
    http
      .csrf(AbstractHttpConfigurer::disable)
      .headers(h -> h.contentSecurityPolicy(csp -> csp.policyDirectives("script-src 'self'")))
      .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

    if (adfsConfigurer != null) {
      http.with(adfsConfigurer, Customizer.withDefaults())
          .authorizeHttpRequests(req -> req
              .requestMatchers("/v3/api-docs/**","/swagger-ui/**","/swagger-ui.html",
                               "/token/{clientId}").permitAll()
              .requestMatchers(HttpMethod.GET).hasAuthority(AppConstants.RESOURCE_READ_ROLE)
              .requestMatchers(HttpMethod.POST, HttpMethod.PUT, HttpMethod.DELETE)
                  .hasAuthority(AppConstants.RESOURCE_WRITE_ROLE)
              .anyRequest().authenticated());
    } else {
      http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
    }
    return http.build();
  }

  // Optional: only in servlet env
  @Bean
  WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring().requestMatchers("/actuator/health", "/actuator/info");
  }
}
This happens because after enabling KSaaS your app starts an application context that is not a Servlet web app (KSaaS starters often bootstrap a non-web/worker context). Your ADFSSecurityConfig always creates a SecurityFilterChain, which requires a ServletContext. In that non-web context there is none, so it blows up.
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@EnableMethodSecurity
@EnableAdfs
@Slf4j
public class ADFSSecurityConfig {

    private final Environment environment;
    private final AdfsConfigurer<HttpSecurity> adfsConfigurer;

    public ADFSSecurityConfig(Environment environment,
                              @Autowired(required = false) AdfsConfigurer<HttpSecurity> adfsConfigurer) {
        this.environment = environment;
        this.adfsConfigurer = adfsConfigurer;
    }

    // ⬇️ Inject ServletContext so Spring defers bean creation until the web server is up
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http, ServletContext servletContext) throws Exception {

        if (!isRunningLocally()) {
            http.requiresChannel(c -> c.anyRequest().requiresSecure());
        } else {
            http.csrf(csrf -> csrf.disable());
        }

        if (adfsConfigurer != null) {
            http.apply(adfsConfigurer);
        }

        http.headers(h -> h.contentSecurityPolicy(p -> p.policyDirectives("script-src 'self'")));

        // ⬇️ Use only literal patterns; NO EndpointRequest.*
        http.authorizeHttpRequests(req -> req
            .requestMatchers(swaggerPaths()).permitAll()
            .requestMatchers(tokenPaths()).permitAll()
            .requestMatchers(actuatorPaths()).permitAll()
            .requestMatchers(HttpMethod.GET,    "/**").hasAuthority(AppConstants.RESOURCE_READ_ROLE)
            .requestMatchers(HttpMethod.POST,   "/**").hasAuthority(AppConstants.RESOURCE_WRITE_ROLE)
            .requestMatchers(HttpMethod.PUT,    "/**").hasAuthority(AppConstants.RESOURCE_WRITE_ROLE)
            .requestMatchers(HttpMethod.DELETE, "/**").hasAuthority(AppConstants.RESOURCE_WRITE_ROLE)
            .anyRequest().authenticated()
        );

        return http.build();
    }

    // Optional: keep a customizer, but make it servlet-safe too
    @Bean
    WebSecurityCustomizer webSecurityCustomizer(ServletContext servletContext) {
        return web -> web.ignoring()
            .requestMatchers(actuatorPaths()); // if you prefer ignoring over permitAll for actuator
    }

    private boolean isRunningLocally() {
        return environment.acceptsProfiles(Profiles.of("local", "dev", "local-h2-enabled", "contract-tests"));
    }

    // --- literal matchers built from your UNPROTECTED_RESOURCE_URIS ---
    private static String[] actuatorPaths() {
        // Your list: keepalive, info, health, metrics, ping, wheelcheck, prometheus, actuator
        return AppConstants.UNPROTECTED_RESOURCE_URIS.stream()
            .flatMap(name -> {
                if ("actuator".equals(name)) {
                    return Stream.of("/actuator", "/actuator/**");
                }
                // map each to /actuator/<name> and /actuator/<name>/**
                return Stream.of("/actuator/" + name, "/actuator/" + name + "/**");
            })
            .toArray(String[]::new);
    }

    private static String[] swaggerPaths() {
        return new String[]{ "/swagger-ui.html", "/swagger-ui/**", "/v3/api-docs/**" };
    }

    private static String[] tokenPaths() {
        return new String[]{ "/token/**", "/token/*", "/token/{clientId}" };
    }
}