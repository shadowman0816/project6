Perfect ‚Äî I understand exactly what you want now üëç
You want a second, standalone, engineer-grade document, just like the Processor Framework document, but entirely focused on SAF (Store-And-Forward).

Below is a complete SAF Enablement Document, written so that:
	‚Ä¢	Any software engineer can read it end-to-end
	‚Ä¢	It can be pasted directly into Confluence
	‚Ä¢	It clearly explains why SAF exists, how policies work, how code behaves, and how to extend it

This document is aligned with your actual code (safService, RetryScheduleService, cutoff logic, step-level enablement, etc.), not theoretical.

‚∏ª

Store-And-Forward (SAF) Enablement

Architecture, Policies, and Execution Model

‚∏ª

1. Purpose of This Document

This document explains the Store-And-Forward (SAF) framework used within the Payroll Processor system.

It is intended for:
	‚Ä¢	Backend engineers
	‚Ä¢	Platform engineers
	‚Ä¢	On-call / support engineers
	‚Ä¢	New team members

This document complements the Processor Framework document and focuses only on:
	‚Ä¢	SAF concepts
	‚Ä¢	SAF policies
	‚Ä¢	SAF execution flow
	‚Ä¢	SAF configuration
	‚Ä¢	SAF interaction with retries and exceptions

‚∏ª

2. What Is SAF? (Engineering Definition)

SAF (Store-And-Forward) is a controlled, delayed retry mechanism used when:
	‚Ä¢	Immediate retries are exhausted or
	‚Ä¢	Processing must be deferred due to time-based or operational constraints

SAF ensures that:
	‚Ä¢	No event is dropped
	‚Ä¢	No processing happens outside allowed windows
	‚Ä¢	Failures are retried safely and deterministically

‚∏ª

3. Why SAF Is Required

3.1 Why Immediate Retry Is Not Enough

Immediate retry works for:
	‚Ä¢	Temporary network failures
	‚Ä¢	Short-lived dependency outages

Immediate retry fails when:
	‚Ä¢	External systems are down for hours
	‚Ä¢	Cutoff times are exceeded
	‚Ä¢	Business rules prohibit same-day execution

‚∏ª

3.2 Problems SAF Solves
Step Execution
   |
   +--> Immediate Retry
           |
           +--> Retry Exhausted
                   |
                   v
              SAF Scheduling
                   |
                   v
           Deferred Replay

SAF is not separate from the processor ‚Äî it is deeply integrated into step execution.

‚∏ª

5. SAF Core Components

5.1 SAF Service (SafService)

Responsibilities
	‚Ä¢	Decide whether a step should execute now
	‚Ä¢	Decide whether execution should be skipped due to SAF
	‚Ä¢	Seed SAF metadata
	‚Ä¢	Coordinate replay eligibility

Key Decisions
	‚Ä¢	Should this step run?
	‚Ä¢	Has this step already been deferred?
	‚Ä¢	Has cutoff time passed?

‚∏ª

5.2 RetryScheduleService

Responsibilities
	‚Ä¢	Persist retry metadata
	‚Ä¢	Calculate next execution time
	‚Ä¢	Enforce cutoff rules
	‚Ä¢	Prevent infinite retries

This service is invoked when:
	‚Ä¢	Exception type = SYSTEM_RETRYABLE
	‚Ä¢	Retry attempts are exhausted
	‚Ä¢	SAF is enabled

‚∏ª

6. SAF Configuration Model

6.1 SAF Configuration Class

public static class SafConfig {
    private boolean enabled;
    private int maxBackoffHours;
    private String cutoffTime;
}


‚∏ª

6.2 SAF Configuration Levels

SAF can be enabled at three levels:
	1.	Workflow level
	2.	Group (Entity) level
	3.	Step level

‚∏ª

6.3 SAF Precedence Rules (Critical)
Step SAF Config
   > Group SAF Config
       > Workflow SAF Config

This allows:
	‚Ä¢	Global defaults
	‚Ä¢	Entity-specific overrides
	‚Ä¢	Step-specific behavior

‚∏ª

7. SAF Execution Lifecycle

7.1 Initial Event Processing
	1.	Event arrives
	2.	WorkflowContext created
	3.	SAF metadata seeded
	4.	Steps begin execution

‚∏ª

7.2 During Step Execution

Before executing any step:

if (!safService.shouldExecute(stepName, event, context)) {
    log.info("Skipping step due to SAF condition");
    context.setStatus(SUCCESS);
    return;
}

This ensures:
	‚Ä¢	Deferred steps are not re-executed prematurely
	‚Ä¢	Replay is controlled

‚∏ª

7.3 SAF Trigger Conditions

SAF is triggered when all of the following are true:
	‚Ä¢	Exception type = SYSTEM_RETRYABLE
	‚Ä¢	Retry count ‚â• maxRetryCount
	‚Ä¢	SAF is enabled (after precedence resolution)

‚∏ª

8. SAF vs Retry (Clear Distinction)

Retry
SAF
Immediate
Deferred
In-memory
Persisted
Short backoff
Hour-based backoff
Same execution cycle
New execution cycle


Retry handles transient failures
SAF handles systemic or time-based failures

‚∏ª

9. Cutoff Time Handling

9.1 What Is Cutoff Time?

Cutoff time defines when processing must stop for the day.

Example:

cutoffTime: "18:30"


‚∏ª

9.2 Why Cutoff Time Exists
	‚Ä¢	Banking windows
	‚Ä¢	External dependency SLAs
	‚Ä¢	Regulatory processing windows

‚∏ª

9.3 SAF Behavior After Cutoff

If current time > cutoffTime:
	‚Ä¢	Step execution is deferred
	‚Ä¢	Event is SAF-scheduled
	‚Ä¢	Replay happens on the next eligible window

‚∏ª

10. SAF Scheduling Logic

When SAF is triggered:
	1.	Failure reason is captured
	2.	Retry metadata is persisted
	3.	Next execution timestamp is calculated
	4.	Event exits current processing safely

No step after the failure executes.

‚∏ª

11. SAF Replay

On replay:
	‚Ä¢	Event is re-loaded
	‚Ä¢	Context is reconstructed
	‚Ä¢	SAF rules are re-evaluated
	‚Ä¢	Execution resumes deterministically

Replay is idempotent and safe.

‚∏ª

12. SAF + Exception Handling

Only SYSTEM_RETRYABLE exceptions trigger SAF.

Exception Type
SAF Behavior
FATAL
No SAF
BUSINESS_VALIDATION
No SAF
SYSTEM_RETRYABLE
SAF eligible
SKIPPABLE
No SAF
FLOW_HALT
No SAF
SILENT_WARNING
No SAF


‚∏ª

13. SAF Observability

Each SAF decision logs:
	‚Ä¢	Step name
	‚Ä¢	Event ID
	‚Ä¢	Retry count
	‚Ä¢	Backoff hours
	‚Ä¢	Cutoff decision
	‚Ä¢	Failure reason

This enables:
	‚Ä¢	Replay debugging
	‚Ä¢	Operational tracing
	‚Ä¢	Compliance auditing

‚∏ª

14. Example SAF Configuration (Payroll)

workflow:
  safEnabled: true
  safConfigs:
    maxBackoffHours: 3

  groups:
    Payroll:
      safEnabled: true
      safConfigs:
        maxBackoffHours: 3
        cutoffTime: ${payroll-app-config.options.saf-cutoff-time}


‚∏ª

15. Example SAF Execution Scenario

Scenario
	‚Ä¢	Payroll reconciliation fails due to SBP outage
	‚Ä¢	Retry attempts exhausted
	‚Ä¢	Cutoff time not exceeded

Outcome
	‚Ä¢	SAF schedules retry within maxBackoffHours

‚∏ª

Another Scenario
	‚Ä¢	Same failure after cutoff time

Outcome
	‚Ä¢	SAF defers execution to next day window

‚∏ª

16. How to Enable SAF for a New Step
	1.	Set safEnabled: true
	2.	Configure maxBackoffHours
	3.	(Optional) Configure cutoffTime
	4.	No code change required

‚∏ª

17. Design Principles
	‚Ä¢	SAF is deterministic
	‚Ä¢	SAF is configuration-driven
	‚Ä¢	SAF is exception-aware
	‚Ä¢	SAF is time-aware
	‚Ä¢	SAF never drops events

‚∏ª

18. Summary

The SAF framework provides:
	‚Ä¢	Controlled failure recovery
	‚Ä¢	Time-aware execution
	‚Ä¢	Replay safety
	‚Ä¢	Operational resilience

It works in tandem with the Processor Framework to ensure financial-grade reliability.

‚∏ª

19. Relationship to Processor Framework
Processor Framework
SAF
Orchestration
Recovery
Step execution
Deferred execution
Immediate retry
Long-term retry
Control flow
Time control

Perfect ‚Äî below is a drop-in continuation to your SAF Enablement document, written at real production depth.
You can paste this as-is into Confluence under new sections.

I‚Äôve split it into two crisp parts:
	1.	Real production scenarios (battle-tested cases)
	2.	Retry vs SAF comparison table (very explicit)

‚∏ª

20. Real Production SAF Scenarios

This section describes actual failure modes that occur in production payroll/payment systems and how SAF behaves deterministically in each case.

These are not theoretical ‚Äî they map directly to your current processor + SAF code paths.

‚∏ª

20.1 External System Outage (SBP / PIM Down for Hours)

Scenario
	‚Ä¢	Payroll processing reaches ReconcileEmployeeWithSBP
	‚Ä¢	SBP API is down (HTTP 503 / timeout)
	‚Ä¢	Step throws SYSTEM_RETRYABLE

What Happens Internally
	1.	Immediate retries occur (e.g., 3 attempts)
	2.	All retries fail
	3.	SAF is enabled for this step
	4.	RetryScheduleService.scheduleRetry(...) is invoked
	5.	Event is persisted with:
	‚Ä¢	Failure reason
	‚Ä¢	Step name
	‚Ä¢	Retry count
	‚Ä¢	Backoff window
	6.	Current processing exits safely

Outcome
	‚Ä¢	Payroll is not cancelled
	‚Ä¢	No duplicate side effects occur
	‚Ä¢	Processing resumes automatically once SBP is back

Why SAF Is Required Here

Retry alone would:
	‚Ä¢	Block threads
	‚Ä¢	Spam downstream systems
	‚Ä¢	Eventually fail the event

SAF converts a system outage into a controlled delay.

‚∏ª

20.2 Cutoff Time Breach (Banking Window Closed)

Scenario
	‚Ä¢	Payroll processing starts at 18:20
	‚Ä¢	Cutoff time is configured as 18:30
	‚Ä¢	A retryable failure occurs at 18:32

What Happens Internally
	1.	Step fails with SYSTEM_RETRYABLE
	2.	Retry attempts exhausted
	3.	SAF evaluates current time vs cutoff
	4.	Cutoff exceeded ‚Üí execution deferred
	5.	SAF schedules replay for next eligible window

Outcome
	‚Ä¢	No processing happens outside allowed window
	‚Ä¢	No partial payroll execution
	‚Ä¢	Event resumes next business window

Why SAF Is Required Here

Retry has no concept of time windows.
SAF enforces time-aware correctness, which is mandatory in payroll systems.

‚∏ª

20.3 Partial Success + Downstream Failure

Scenario
	‚Ä¢	Steps executed successfully:
	‚Ä¢	ReadIncomingPayrollEvent
	‚Ä¢	ValidatePayrollStatusFromGusto
	‚Ä¢	PersistPayrollHierarchyToDatabase
	‚Ä¢	Failure occurs at SendRequestToPIM

What Happens Internally
	1.	Failure classified as SYSTEM_RETRYABLE
	2.	Immediate retries fail
	3.	SAF is triggered
	4.	SAF replay resumes at the failed step
	5.	Already completed steps are not re-executed

Outcome
	‚Ä¢	Database writes are not duplicated
	‚Ä¢	Idempotency is preserved
	‚Ä¢	PIM eventually receives request exactly once

Why SAF Is Required Here

Retrying the entire flow would:
	‚Ä¢	Duplicate DB writes
	‚Ä¢	Violate idempotency
	‚Ä¢	Create reconciliation issues

SAF enables step-level recovery, not full replay.

‚∏ª

20.4 Long Dependency Degradation (Slow but Not Down)

Scenario
	‚Ä¢	External API responds intermittently
	‚Ä¢	Some calls succeed, some timeout
	‚Ä¢	Retries intermittently succeed

What Happens Internally
	1.	Retry attempts occur
	2.	If retry succeeds ‚Üí continue
	3.	If retries consistently fail ‚Üí SAF
	4.	SAF smooths out instability by spacing retries

Outcome
	‚Ä¢	System load is controlled
	‚Ä¢	External system is not overwhelmed
	‚Ä¢	Payroll processing eventually completes

Why SAF Is Required Here

Retry alone causes:
	‚Ä¢	Thundering herd
	‚Ä¢	Cascading failures
	‚Ä¢	CPU spikes

SAF introduces backpressure into the system.

‚∏ª

20.5 Same-Day SAF vs Next-Day SAF

Scenario A ‚Äì Same-Day
	‚Ä¢	Failure occurs at 14:00
	‚Ä¢	Cutoff is 18:30
	‚Ä¢	maxBackoffHours = 3

Outcome
	‚Ä¢	SAF schedules retry at ~17:00
	‚Ä¢	Processing completes same day

‚∏ª

Scenario B ‚Äì Next-Day
	‚Ä¢	Failure occurs at 17:45
	‚Ä¢	Backoff pushes execution beyond cutoff

Outcome
	‚Ä¢	SAF defers to next processing window
	‚Ä¢	Payroll resumes next day safely

‚∏ª

20.6 What SAF Explicitly Does Not Do

SAF does not trigger for:
	‚Ä¢	BUSINESS_VALIDATION (payroll is cancelled intentionally)
	‚Ä¢	FATAL (hard stop)
	‚Ä¢	SKIPPABLE (log & continue)
	‚Ä¢	FLOW_HALT (intentional termination)

This prevents semantic misuse of SAF.

‚∏ª

21. Retry vs SAF ‚Äì Comparison Table

This table is designed to be very explicit for engineers and reviewers.

‚∏ª

21.1 Conceptual Comparison
Dimension
Retry
SAF (Store-And-Forward)
Purpose
Handle transient failures
Handle prolonged / time-bound failures
Timing
Immediate
Deferred
State
In-memory
Persisted
Duration
Milliseconds‚Äìseconds
Minutes‚Äìhours
Thread usage
Blocking
Non-blocking
Cutoff awareness
‚ùå No
‚úÖ Yes
Replay safety
Limited
Guaranteed
Idempotency
Risky if misused
Safe by design


‚∏ª

21.5 When to Use Which (Rule of Thumb)

Use Retry when:
	‚Ä¢	Failure is transient
	‚Ä¢	Recovery is expected within seconds
	‚Ä¢	No time window constraints exist

Use SAF when:
	‚Ä¢	Failure may last minutes/hours
	‚Ä¢	Cutoff windows matter
	‚Ä¢	Idempotency must be preserved
	‚Ä¢	Operational control is required

‚∏ª

22. Final Takeaway for Engineers

Retry and SAF are not alternatives ‚Äî they are complementary layers.

Got it ‚Äî this is an important conceptual gap and you‚Äôre right to call it out explicitly.
Below is a Confluence-ready section you can append to the Processor / SAF docs.

This explains, clearly and practically, the different replay / retry policies, how they behave, how config drives them, and when to use which ‚Äî with a concrete example.

You can paste this as-is into Confluence.

‚∏ª

Retry & Replay Policies

Execution Semantics, Configuration, and Usage


‚∏ª

1. Why Replay Policies Exist

When a workflow fails and is retried (either immediately or via SAF), the system must answer a critical question:

Where should execution resume from?

Blindly restarting everything or blindly resuming from the failure point can both be incorrect, depending on:
	‚Ä¢	Side effects already committed
	‚Ä¢	Idempotency guarantees
	‚Ä¢	Business semantics
	‚Ä¢	External system behavior

To address this, the framework supports explicit replay policies.

‚∏ª

2. Overview of Replay Policies

The framework supports the following execution replay strategies:
	1.	Restart from Beginning
	2.	Restart from Beginning with Skipped Steps
	3.	Resume from Failed Step (Last Failed Step)

Each policy is intentional, config-driven, and deterministic.

‚∏ª

3. Common Example Workflow (Used Below)

Assume the following workflow for payroll.processed:

1. ReadIncomingPayrollEvent
2. ValidatePayrollStatusFromGusto
3. ValidateCustomerInternalEligibility
4. ReconcileEmployeeWithSBP
5. PersistPayrollHierarchyToDatabase
6. SendRequestToPIM

Assume failure occurs at Step 4 (ReconcileEmployeeWithSBP).

‚∏ª

4. Policy 1 ‚Äî Restart from Beginning

4.1 What It Means

Every retry or SAF replay re-executes the workflow from Step 1, regardless of where the failure occurred.

‚∏ª

4.2 Execution Flow
Retry / SAF Replay
   ‚Üì
Step 1
Step 2
Step 3
Step 4 (fails again or succeeds)
Step 5
Step 6


‚∏ª

4.3 When This Policy Is Appropriate

Use this when:
	‚Ä¢	All steps are idempotent
	‚Ä¢	Earlier steps must be revalidated
	‚Ä¢	External state may have changed
	‚Ä¢	Business correctness > performance

Typical use cases
	‚Ä¢	Validation-heavy flows
	‚Ä¢	Read-only or safe external calls
	‚Ä¢	Stateless workflows

‚∏ª

4.4 Risks
	‚Ä¢	Repeated external calls
	‚Ä¢	Higher latency
	‚Ä¢	Increased dependency load

‚∏ª

4.5 Conceptual Config (Illustrative)

replayPolicy: START_FROM_BEGINNING


‚∏ª

5. Policy 2 ‚Äî Restart from Beginning with Skipped Steps (Soft Policy)

5.1 What It Means

Execution starts from Step 1, but steps that have already completed successfully are skipped automatically.

This is often referred to as a ‚Äúsoft restart‚Äù.

‚∏ª

5.2 Execution Flow

Assume Steps 1‚Äì3 already succeeded.

Retry / SAF Replay
   ‚Üì
Step 1 (skipped)
Step 2 (skipped)
Step 3 (skipped)
Step 4 (retry)
Step 5
Step 6


‚∏ª

5.3 How Skipping Works
	‚Ä¢	WorkflowContext tracks completed steps
	‚Ä¢	SAF metadata persists execution state
	‚Ä¢	Before executing a step, the framework checks:
	‚Ä¢	Has this step already completed successfully?
	‚Ä¢	Is the policy allowing skip?

If yes ‚Üí skip execution safely

‚∏ª

5.4 When This Policy Is Appropriate (Most Common)

Use this when:
	‚Ä¢	Earlier steps have side effects
	‚Ä¢	Re-running earlier steps is unsafe or expensive
	‚Ä¢	You want safety without duplication

Typical use cases
	‚Ä¢	Database writes
	‚Ä¢	Identifier generation
	‚Ä¢	One-time external mutations
	‚Ä¢	Financial state changes

This is the recommended default policy for most payroll and payment flows.

‚∏ª

5.5 Why This Is Called a ‚ÄúSoft Policy‚Äù
	‚Ä¢	Execution logically restarts from the beginning
	‚Ä¢	But physically avoids redoing completed work
	‚Ä¢	Preserves determinism and safety

‚∏ª

5.6 Conceptual Config (Illustrative)

replayPolicy: START_FROM_BEGINNING_WITH_SKIPPED_STEPS


‚∏ª

6. Policy 3 ‚Äî Resume from Failed Step (Hard Resume)

6.1 What It Means

Execution resumes exactly from the last failed step, skipping everything before it unconditionally.

‚∏ª

6.2 Execution Flow

Retry / SAF Replay
   ‚Üì
Step 4 (retry)
Step 5
Step 6


‚∏ª

6.3 When This Policy Is Appropriate

Use this when:
	‚Ä¢	Prior steps are guaranteed complete
	‚Ä¢	Prior steps are not safe to re-evaluate
	‚Ä¢	Failure is isolated and well understood

Typical use cases
	‚Ä¢	Downstream notification failures
	‚Ä¢	Post-persistence integrations
	‚Ä¢	Idempotent downstream-only retries

‚∏ª

6.4 Risks
	‚Ä¢	Earlier validation is not rechecked
	‚Ä¢	Assumes state consistency
	‚Ä¢	Higher risk if misused

This policy should be used sparingly and intentionally.

‚∏ª

6.5 Conceptual Config (Illustrative)

replayPolicy: RESUME_FROM_FAILED_STEP


‚∏ª

7. How the Policy Flows Through the System

7.1 At Failure Time
	1.	Step fails
	2.	Exception is classified
	3.	Retry or SAF is triggered
	4.	WorkflowContext persists:
	‚Ä¢	Failed step name
	‚Ä¢	Completed steps
	‚Ä¢	Replay policy

‚∏ª

7.2 At Replay Time
	1.	Event is reloaded
	2.	WorkflowContext is reconstructed
	3.	Replay policy is evaluated
	4.	Step iterator is adjusted accordingly
	5.	Execution proceeds deterministically

‚∏ª

8. How to Use a Soft Policy (Practically)

8.1 When Someone Says ‚ÄúUse Soft Policy‚Äù, It Means:
	‚Ä¢	Start from beginning
	‚Ä¢	Skip already successful steps
	‚Ä¢	Preserve side effects
	‚Ä¢	Avoid duplication

This is ideal for:
	‚Ä¢	Payroll processing
	‚Ä¢	Contractor payments
	‚Ä¢	Multi-step financial workflows

‚∏ª

8.2 What Must Be True to Use Soft Policy Safely

To safely use START_FROM_BEGINNING_WITH_SKIPPED_STEPS:
	1.	Steps must:
	‚Ä¢	Record success explicitly
	‚Ä¢	Be idempotent or skip-safe
	2.	WorkflowContext must persist:
	‚Ä¢	Step completion markers
	3.	SAF replay must:
	‚Ä¢	Rehydrate context correctly

Your current framework already supports this.

‚∏ª

9. Comparison of Policies (Quick Table)

Policy
Re-executes All
Skips Completed
Safe for Side Effects
Typical Usage
Start from Beginning
‚úÖ
‚ùå
‚ùå
Validation-heavy flows
Start from Beginning + Skip
‚ö†Ô∏è Logical only
‚úÖ
‚úÖ
Default / Recommended
Resume from Failed Step
‚ùå
‚úÖ
‚ö†Ô∏è
Isolated downstream failures



