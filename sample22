Perfect ‚Äî I understand exactly what you want now üëç
You want a second, standalone, engineer-grade document, just like the Processor Framework document, but entirely focused on SAF (Store-And-Forward).

Below is a complete SAF Enablement Document, written so that:
	‚Ä¢	Any software engineer can read it end-to-end
	‚Ä¢	It can be pasted directly into Confluence
	‚Ä¢	It clearly explains why SAF exists, how policies work, how code behaves, and how to extend it

This document is aligned with your actual code (safService, RetryScheduleService, cutoff logic, step-level enablement, etc.), not theoretical.

‚∏ª

Store-And-Forward (SAF) Enablement

Architecture, Policies, and Execution Model

‚∏ª

1. Purpose of This Document

This document explains the Store-And-Forward (SAF) framework used within the Payroll Processor system.

It is intended for:
	‚Ä¢	Backend engineers
	‚Ä¢	Platform engineers
	‚Ä¢	On-call / support engineers
	‚Ä¢	New team members

This document complements the Processor Framework document and focuses only on:
	‚Ä¢	SAF concepts
	‚Ä¢	SAF policies
	‚Ä¢	SAF execution flow
	‚Ä¢	SAF configuration
	‚Ä¢	SAF interaction with retries and exceptions

‚∏ª

2. What Is SAF? (Engineering Definition)

SAF (Store-And-Forward) is a controlled, delayed retry mechanism used when:
	‚Ä¢	Immediate retries are exhausted or
	‚Ä¢	Processing must be deferred due to time-based or operational constraints

SAF ensures that:
	‚Ä¢	No event is dropped
	‚Ä¢	No processing happens outside allowed windows
	‚Ä¢	Failures are retried safely and deterministically

‚∏ª

3. Why SAF Is Required

3.1 Why Immediate Retry Is Not Enough

Immediate retry works for:
	‚Ä¢	Temporary network failures
	‚Ä¢	Short-lived dependency outages

Immediate retry fails when:
	‚Ä¢	External systems are down for hours
	‚Ä¢	Cutoff times are exceeded
	‚Ä¢	Business rules prohibit same-day execution

‚∏ª

3.2 Problems SAF Solves
Step Execution
   |
   +--> Immediate Retry
           |
           +--> Retry Exhausted
                   |
                   v
              SAF Scheduling
                   |
                   v
           Deferred Replay

SAF is not separate from the processor ‚Äî it is deeply integrated into step execution.

‚∏ª

5. SAF Core Components

5.1 SAF Service (SafService)

Responsibilities
	‚Ä¢	Decide whether a step should execute now
	‚Ä¢	Decide whether execution should be skipped due to SAF
	‚Ä¢	Seed SAF metadata
	‚Ä¢	Coordinate replay eligibility

Key Decisions
	‚Ä¢	Should this step run?
	‚Ä¢	Has this step already been deferred?
	‚Ä¢	Has cutoff time passed?

‚∏ª

5.2 RetryScheduleService

Responsibilities
	‚Ä¢	Persist retry metadata
	‚Ä¢	Calculate next execution time
	‚Ä¢	Enforce cutoff rules
	‚Ä¢	Prevent infinite retries

This service is invoked when:
	‚Ä¢	Exception type = SYSTEM_RETRYABLE
	‚Ä¢	Retry attempts are exhausted
	‚Ä¢	SAF is enabled

‚∏ª

6. SAF Configuration Model

6.1 SAF Configuration Class

public static class SafConfig {
    private boolean enabled;
    private int maxBackoffHours;
    private String cutoffTime;
}


‚∏ª

6.2 SAF Configuration Levels

SAF can be enabled at three levels:
	1.	Workflow level
	2.	Group (Entity) level
	3.	Step level

‚∏ª

6.3 SAF Precedence Rules (Critical)
Step SAF Config
   > Group SAF Config
       > Workflow SAF Config

This allows:
	‚Ä¢	Global defaults
	‚Ä¢	Entity-specific overrides
	‚Ä¢	Step-specific behavior

‚∏ª

7. SAF Execution Lifecycle

7.1 Initial Event Processing
	1.	Event arrives
	2.	WorkflowContext created
	3.	SAF metadata seeded
	4.	Steps begin execution

‚∏ª

7.2 During Step Execution

Before executing any step:

if (!safService.shouldExecute(stepName, event, context)) {
    log.info("Skipping step due to SAF condition");
    context.setStatus(SUCCESS);
    return;
}

This ensures:
	‚Ä¢	Deferred steps are not re-executed prematurely
	‚Ä¢	Replay is controlled

‚∏ª

7.3 SAF Trigger Conditions

SAF is triggered when all of the following are true:
	‚Ä¢	Exception type = SYSTEM_RETRYABLE
	‚Ä¢	Retry count ‚â• maxRetryCount
	‚Ä¢	SAF is enabled (after precedence resolution)

‚∏ª

8. SAF vs Retry (Clear Distinction)

Retry
SAF
Immediate
Deferred
In-memory
Persisted
Short backoff
Hour-based backoff
Same execution cycle
New execution cycle


Retry handles transient failures
SAF handles systemic or time-based failures

‚∏ª

9. Cutoff Time Handling

9.1 What Is Cutoff Time?

Cutoff time defines when processing must stop for the day.

Example:

cutoffTime: "18:30"


‚∏ª

9.2 Why Cutoff Time Exists
	‚Ä¢	Banking windows
	‚Ä¢	External dependency SLAs
	‚Ä¢	Regulatory processing windows

‚∏ª

9.3 SAF Behavior After Cutoff

If current time > cutoffTime:
	‚Ä¢	Step execution is deferred
	‚Ä¢	Event is SAF-scheduled
	‚Ä¢	Replay happens on the next eligible window

‚∏ª

10. SAF Scheduling Logic

When SAF is triggered:
	1.	Failure reason is captured
	2.	Retry metadata is persisted
	3.	Next execution timestamp is calculated
	4.	Event exits current processing safely

No step after the failure executes.

‚∏ª

11. SAF Replay

On replay:
	‚Ä¢	Event is re-loaded
	‚Ä¢	Context is reconstructed
	‚Ä¢	SAF rules are re-evaluated
	‚Ä¢	Execution resumes deterministically

Replay is idempotent and safe.

‚∏ª

12. SAF + Exception Handling

Only SYSTEM_RETRYABLE exceptions trigger SAF.

Exception Type
SAF Behavior
FATAL
No SAF
BUSINESS_VALIDATION
No SAF
SYSTEM_RETRYABLE
SAF eligible
SKIPPABLE
No SAF
FLOW_HALT
No SAF
SILENT_WARNING
No SAF


‚∏ª

13. SAF Observability

Each SAF decision logs:
	‚Ä¢	Step name
	‚Ä¢	Event ID
	‚Ä¢	Retry count
	‚Ä¢	Backoff hours
	‚Ä¢	Cutoff decision
	‚Ä¢	Failure reason

This enables:
	‚Ä¢	Replay debugging
	‚Ä¢	Operational tracing
	‚Ä¢	Compliance auditing

‚∏ª

14. Example SAF Configuration (Payroll)

workflow:
  safEnabled: true
  safConfigs:
    maxBackoffHours: 3

  groups:
    Payroll:
      safEnabled: true
      safConfigs:
        maxBackoffHours: 3
        cutoffTime: ${payroll-app-config.options.saf-cutoff-time}


‚∏ª

15. Example SAF Execution Scenario

Scenario
	‚Ä¢	Payroll reconciliation fails due to SBP outage
	‚Ä¢	Retry attempts exhausted
	‚Ä¢	Cutoff time not exceeded

Outcome
	‚Ä¢	SAF schedules retry within maxBackoffHours

‚∏ª

Another Scenario
	‚Ä¢	Same failure after cutoff time

Outcome
	‚Ä¢	SAF defers execution to next day window

‚∏ª

16. How to Enable SAF for a New Step
	1.	Set safEnabled: true
	2.	Configure maxBackoffHours
	3.	(Optional) Configure cutoffTime
	4.	No code change required

‚∏ª

17. Design Principles
	‚Ä¢	SAF is deterministic
	‚Ä¢	SAF is configuration-driven
	‚Ä¢	SAF is exception-aware
	‚Ä¢	SAF is time-aware
	‚Ä¢	SAF never drops events

‚∏ª

18. Summary

The SAF framework provides:
	‚Ä¢	Controlled failure recovery
	‚Ä¢	Time-aware execution
	‚Ä¢	Replay safety
	‚Ä¢	Operational resilience

It works in tandem with the Processor Framework to ensure financial-grade reliability.

‚∏ª

19. Relationship to Processor Framework
Processor Framework
SAF
Orchestration
Recovery
Step execution
Deferred execution
Immediate retry
Long-term retry
Control flow
Time control

Perfect ‚Äî below is a drop-in continuation to your SAF Enablement document, written at real production depth.
You can paste this as-is into Confluence under new sections.

I‚Äôve split it into two crisp parts:
	1.	Real production scenarios (battle-tested cases)
	2.	Retry vs SAF comparison table (very explicit)

‚∏ª

20. Real Production SAF Scenarios

This section describes actual failure modes that occur in production payroll/payment systems and how SAF behaves deterministically in each case.

These are not theoretical ‚Äî they map directly to your current processor + SAF code paths.

‚∏ª

20.1 External System Outage (SBP / PIM Down for Hours)

Scenario
	‚Ä¢	Payroll processing reaches ReconcileEmployeeWithSBP
	‚Ä¢	SBP API is down (HTTP 503 / timeout)
	‚Ä¢	Step throws SYSTEM_RETRYABLE

What Happens Internally
	1.	Immediate retries occur (e.g., 3 attempts)
	2.	All retries fail
	3.	SAF is enabled for this step
	4.	RetryScheduleService.scheduleRetry(...) is invoked
	5.	Event is persisted with:
	‚Ä¢	Failure reason
	‚Ä¢	Step name
	‚Ä¢	Retry count
	‚Ä¢	Backoff window
	6.	Current processing exits safely

Outcome
	‚Ä¢	Payroll is not cancelled
	‚Ä¢	No duplicate side effects occur
	‚Ä¢	Processing resumes automatically once SBP is back

Why SAF Is Required Here

Retry alone would:
	‚Ä¢	Block threads
	‚Ä¢	Spam downstream systems
	‚Ä¢	Eventually fail the event

SAF converts a system outage into a controlled delay.

‚∏ª

20.2 Cutoff Time Breach (Banking Window Closed)

Scenario
	‚Ä¢	Payroll processing starts at 18:20
	‚Ä¢	Cutoff time is configured as 18:30
	‚Ä¢	A retryable failure occurs at 18:32

What Happens Internally
	1.	Step fails with SYSTEM_RETRYABLE
	2.	Retry attempts exhausted
	3.	SAF evaluates current time vs cutoff
	4.	Cutoff exceeded ‚Üí execution deferred
	5.	SAF schedules replay for next eligible window

Outcome
	‚Ä¢	No processing happens outside allowed window
	‚Ä¢	No partial payroll execution
	‚Ä¢	Event resumes next business window

Why SAF Is Required Here

Retry has no concept of time windows.
SAF enforces time-aware correctness, which is mandatory in payroll systems.

‚∏ª

20.3 Partial Success + Downstream Failure

Scenario
	‚Ä¢	Steps executed successfully:
	‚Ä¢	ReadIncomingPayrollEvent
	‚Ä¢	ValidatePayrollStatusFromGusto
	‚Ä¢	PersistPayrollHierarchyToDatabase
	‚Ä¢	Failure occurs at SendRequestToPIM

What Happens Internally
	1.	Failure classified as SYSTEM_RETRYABLE
	2.	Immediate retries fail
	3.	SAF is triggered
	4.	SAF replay resumes at the failed step
	5.	Already completed steps are not re-executed

Outcome
	‚Ä¢	Database writes are not duplicated
	‚Ä¢	Idempotency is preserved
	‚Ä¢	PIM eventually receives request exactly once

Why SAF Is Required Here

Retrying the entire flow would:
	‚Ä¢	Duplicate DB writes
	‚Ä¢	Violate idempotency
	‚Ä¢	Create reconciliation issues

SAF enables step-level recovery, not full replay.

‚∏ª

20.4 Long Dependency Degradation (Slow but Not Down)

Scenario
	‚Ä¢	External API responds intermittently
	‚Ä¢	Some calls succeed, some timeout
	‚Ä¢	Retries intermittently succeed

What Happens Internally
	1.	Retry attempts occur
	2.	If retry succeeds ‚Üí continue
	3.	If retries consistently fail ‚Üí SAF
	4.	SAF smooths out instability by spacing retries

Outcome
	‚Ä¢	System load is controlled
	‚Ä¢	External system is not overwhelmed
	‚Ä¢	Payroll processing eventually completes

Why SAF Is Required Here

Retry alone causes:
	‚Ä¢	Thundering herd
	‚Ä¢	Cascading failures
	‚Ä¢	CPU spikes

SAF introduces backpressure into the system.

‚∏ª

20.5 Same-Day SAF vs Next-Day SAF

Scenario A ‚Äì Same-Day
	‚Ä¢	Failure occurs at 14:00
	‚Ä¢	Cutoff is 18:30
	‚Ä¢	maxBackoffHours = 3

Outcome
	‚Ä¢	SAF schedules retry at ~17:00
	‚Ä¢	Processing completes same day

‚∏ª

Scenario B ‚Äì Next-Day
	‚Ä¢	Failure occurs at 17:45
	‚Ä¢	Backoff pushes execution beyond cutoff

Outcome
	‚Ä¢	SAF defers to next processing window
	‚Ä¢	Payroll resumes next day safely

‚∏ª

20.6 What SAF Explicitly Does Not Do

SAF does not trigger for:
	‚Ä¢	BUSINESS_VALIDATION (payroll is cancelled intentionally)
	‚Ä¢	FATAL (hard stop)
	‚Ä¢	SKIPPABLE (log & continue)
	‚Ä¢	FLOW_HALT (intentional termination)

This prevents semantic misuse of SAF.

‚∏ª

21. Retry vs SAF ‚Äì Comparison Table

This table is designed to be very explicit for engineers and reviewers.

‚∏ª

21.1 Conceptual Comparison
Dimension
Retry
SAF (Store-And-Forward)
Purpose
Handle transient failures
Handle prolonged / time-bound failures
Timing
Immediate
Deferred
State
In-memory
Persisted
Duration
Milliseconds‚Äìseconds
Minutes‚Äìhours
Thread usage
Blocking
Non-blocking
Cutoff awareness
‚ùå No
‚úÖ Yes
Replay safety
Limited
Guaranteed
Idempotency
Risky if misused
Safe by design


‚∏ª

21.5 When to Use Which (Rule of Thumb)

Use Retry when:
	‚Ä¢	Failure is transient
	‚Ä¢	Recovery is expected within seconds
	‚Ä¢	No time window constraints exist

Use SAF when:
	‚Ä¢	Failure may last minutes/hours
	‚Ä¢	Cutoff windows matter
	‚Ä¢	Idempotency must be preserved
	‚Ä¢	Operational control is required

‚∏ª

22. Final Takeaway for Engineers

Retry and SAF are not alternatives ‚Äî they are complementary layers.


