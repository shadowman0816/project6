no package net.jpmchase.payroll.processor.service;

import net.jpmchase.payroll.processor.common.config.StepConfig;
import net.jpmchase.payroll.processor.common.context.WorkflowContext;
import net.jpmchase.payroll.processor.conditions.ExecutionCondition;
import net.jpmchase.payroll.processor.exception.ProcessorException;
import net.jpmchase.payroll.processor.exception.ProcessorExceptionType;
import net.jpmchase.payroll.processor.model.Event;
import net.jpmchase.payroll.processor.model.MessageBody;
import net.jpmchase.payroll.processor.model.enums.EventStatus;
import net.jpmchase.payroll.processor.registry.ConditionRegistry;
import net.jpmchase.payroll.processor.registry.WorkFlowRegistry;
import net.jpmchase.payroll.processor.registry.Steps;
import net.jpmchase.payroll.processor.retry.RetryScheduleService;
import net.jpmchase.payroll.processor.saf.SafService; // <-- make sure package matches yours

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EventProcessorServiceTest {

    @Mock private WorkFlowRegistry workFlowRegistry;
    @Mock private Steps stepRegistry;
    @Mock private ConditionRegistry conditionRegistry;
    @Mock private RetryScheduleService retryScheduleService;
    @Mock private SafService safService;

    @InjectMocks
    private EventProcessorService service;

    /** helper to build a minimal Event */
    private Event buildMockEvent(String entityType, String eventType) {
        MessageBody body = new MessageBody();
        body.setEntityType(entityType);
        body.setEventType(eventType);
        body.setEventId(UUID.randomUUID());
        body.setResourceUUID(UUID.randomUUID());

        Event e = new Event();
        e.setMessageBody(body);
        e.setProcessingStatus(EventStatus.IN_PROCESS);
        e.setEventLogId(UUID.randomUUID());
        e.setHeaders(Collections.emptyMap()); // SAF seed will look at headers
        return e;
    }

    /* ------------------------------------------------------------------
       NEW TEST 1:
       Verify safService.seed(...) is called at the start of processEvent()
       and normal happy-path step is still executed.
     ------------------------------------------------------------------ */
    @Test
    void test_processEvent_invokesSafSeed_andExecutesStep() {
        String entityType = "ENTITY";
        String eventType  = "EVENT";
        Event event = buildMockEvent(entityType, eventType);

        // arrange workflow: single non-retry step
        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("mockStep");
        stepConfig.setRetryEnabled(false); // no loop/retry logic

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        // stepRegistry.get("mockStep") -> mock step impl
        net.jpmchase.payroll.processor.steps.Step mockStep = mock(net.jpmchase.payroll.processor.steps.Step.class);
        when(stepRegistry.get("mockStep")).thenReturn(mockStep);

        // SAF should allow execution in this scenario
        when(safService.shouldExecute(
                eq("mockStep"),
                any(),                // executeOnCondition
                same(event),
                any()                 // baseCondition supplier
        )).thenReturn(true);

        // conditionRegistry won't be called if baseCondition short-circuits via safService.shouldExecute(...)
        // but let's just not blow up if it is:
        when(conditionRegistry.get(anyString())).thenReturn(mock(ExecutionCondition.class));

        // act
        service.processEvent(event);

        // assert 1: safService.seed was called with the same Event and some WorkflowContext
        ArgumentCaptor<WorkflowContext> ctxCaptor = ArgumentCaptor.forClass(WorkflowContext.class);
        verify(safService).seed(same(event), ctxCaptor.capture());

        WorkflowContext seededCtx = ctxCaptor.getValue();
        // sanity check: after seeding, context should have INITIATED or IN_PROCESS, etc.
        // We know processEvent() does:
        //   context.setStatus(INITIATED);
        //   context.put(EVENT, event);
        //   ...
        // So we can assert status got initialized:
        assertEquals("INITIATED", seededCtx.getStatus().name());

        // assert 2: our step actually executed once
        verify(mockStep, times(1)).execute(any(WorkflowContext.class));
    }

    /* ------------------------------------------------------------------
       NEW TEST 2:
       SAF says "skip this step" -> step should NOT execute.
       This exercises the branch in executeStepWithRetry() where
       safService.shouldExecute(...) returns false.
     ------------------------------------------------------------------ */
    @Test
    void test_processEvent_skipsStep_whenSafBlocksExecution() {
        String entityType = "ENTITY";
        String eventType  = "EVENT";
        Event event = buildMockEvent(entityType, eventType);

        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("safBlockedStep");
        stepConfig.setRetryEnabled(false);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        net.jpmchase.payroll.processor.steps.Step mockStep =
            mock(net.jpmchase.payroll.processor.steps.Step.class);
        when(stepRegistry.get("safBlockedStep")).thenReturn(mockStep);

        // SAF vetoes execution
        when(safService.shouldExecute(
                eq("safBlockedStep"),
                any(),
                same(event),
                any()
        )).thenReturn(false);

        service.processEvent(event);

        // SAF seed still gets called
        verify(safService).seed(any(Event.class), any(WorkflowContext.class));

        // mockStep should never run because SAF said don't execute
        verify(mockStep, never()).execute(any());
    }

    /* ------------------------------------------------------------------
       EXISTING behaviors below (adapted from your screenshots).
       Iâ€™ll restate / modernize a couple of them to keep the file coherent.
     ------------------------------------------------------------------ */

    @Test
    void test_processEvent_noStepsFound() {
        String entityType = "ENTITY";
        String eventType  = "EVENT";
        Event event = buildMockEvent(entityType, eventType);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(Collections.emptyList());

        service.processEvent(event);

        // safService.seed still called
        verify(safService).seed(any(Event.class), any(WorkflowContext.class));

        // nothing else to verify really except we did hit registry once
        verify(workFlowRegistry, times(1))
            .getStepsForEvent(entityType, eventType);
    }

    @Test
    void test_executeStep_stepExecutesSuccessfully() throws Exception {
        String entityType = "ENTITY";
        String eventType  = "EVENT";
        Event event = buildMockEvent(entityType, eventType);

        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("mockStep");
        stepConfig.setRetryEnabled(false);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        net.jpmchase.payroll.processor.steps.Step mockStep =
            mock(net.jpmchase.payroll.processor.steps.Step.class);
        when(stepRegistry.get("mockStep")).thenReturn(mockStep);

        when(safService.shouldExecute(
                eq("mockStep"),
                any(),
                same(event),
                any()
        )).thenReturn(true);

        service.processEvent(event);

        // executed once
        verify(mockStep, times(1)).execute(any(WorkflowContext.class));
        // no retry scheduling for success
        verifyNoInteractions(retryScheduleService);
    }

    @Test
    void test_executeStep_stepFailsAndRetriesSuccessfully() throws Exception {
        String entityType = "ENTITY";
        String eventType  = "RETRY_EVENT";
        Event event = buildMockEvent(entityType, eventType);

        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("retryStep");
        stepConfig.setRetryEnabled(true);
        StepConfig.RetryConfig retryCfg = new StepConfig.RetryConfig();
        retryCfg.setMaxRetryCount(2);
        retryCfg.setRetryBackOffMs("10");
        stepConfig.setRetryConfigs(retryCfg);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        net.jpmchase.payroll.processor.steps.Step mockStep =
            mock(net.jpmchase.payroll.processor.steps.Step.class);

        // First call throws SYSTEM_RETRYABLE, second call succeeds
        doThrow(new ProcessorException(
                    ProcessorExceptionType.SYSTEM_RETRYABLE,
                    "temporary",
                    "retryable"))
            .doNothing()
            .when(mockStep).execute(any(WorkflowContext.class));

        when(stepRegistry.get("retryStep")).thenReturn(mockStep);

        when(safService.shouldExecute(
                eq("retryStep"),
                any(),
                same(event),
                any()
        )).thenReturn(true);

        service.processEvent(event);

        // step.execute called twice (retry once, then success)
        verify(mockStep, times(2)).execute(any(WorkflowContext.class));

        // for SYSTEM_RETRYABLE we expect scheduleRetry(...) to be called only
        // AFTER final failure and only if safEnabled on that step; but in this
        // test the second attempt succeeds, so no scheduleRetry
        verifyNoInteractions(retryScheduleService);
    }

    @Test
    void test_executeStep_failsFatally_noRetry() throws Exception {
        String entityType = "ENTITY";
        String eventType  = "FATAL_EVENT";
        Event event = buildMockEvent(entityType, eventType);

        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("fatalStep");
        stepConfig.setRetryEnabled(true);
        StepConfig.RetryConfig retryCfg = new StepConfig.RetryConfig();
        retryCfg.setMaxRetryCount(1);
        retryCfg.setRetryBackOffMs("10");
        stepConfig.setRetryConfigs(retryCfg);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        net.jpmchase.payroll.processor.steps.Step mockStep =
            mock(net.jpmchase.payroll.processor.steps.Step.class);

        doThrow(new ProcessorException(
                    ProcessorExceptionType.FATAL,
                    "failure",
                    "fatal"))
            .when(mockStep).execute(any(WorkflowContext.class));

        when(stepRegistry.get("fatalStep")).thenReturn(mockStep);

        when(safService.shouldExecute(
                eq("fatalStep"),
                any(),
                same(event),
                any()
        )).thenReturn(true);

        service.processEvent(event);

        // execute called once (fatal stops loop)
        verify(mockStep, times(1)).execute(any(WorkflowContext.class));

        // no retry scheduled on FATAL
        verifyNoInteractions(retryScheduleService);
    }

    @Test
    void test_shouldExecute_returnsFalse_whenConditionFails() {
        String entityType = "ENTITY";
        String eventType  = "COND_EVENT";
        Event event = buildMockEvent(entityType, eventType);

        StepConfig stepConfig = new StepConfig();
        stepConfig.setName("conditionalStep");
        stepConfig.setExecuteOnCondition("myCondition");
        stepConfig.setRetryEnabled(false);

        when(workFlowRegistry.getStepsForEvent(entityType, eventType))
            .thenReturn(List.of(stepConfig));

        // SAF says "yes, you MAY run this step" so we defer to condition
        when(safService.shouldExecute(
                eq("conditionalStep"),
                eq("myCondition"),
                same(event),
                any()
        )).thenAnswer(invocation -> {
            // call the BooleanSupplier (4th arg) ourselves to mimic real flow
            BooleanSupplier base = invocation.getArgument(3, BooleanSupplier.class);
            return base.getAsBoolean(); // just delegate to condition logic
        });

        // mock conditionRegistry -> condition.evaluate() returns false
        ExecutionCondition condition = mock(ExecutionCondition.class);
        when(condition.evaluate(any())).thenReturn(false);
        when(conditionRegistry.get("myCondition")).thenReturn(condition);

        // act
        service.processEvent(event);

        // assert:
        //  - condition evaluated once
        //  - step NEVER executed
        verify(condition, times(1)).evaluate(any(WorkflowContext.class));
        verify(stepRegistry.get("conditionalStep"), never()).execute(any());
    }
}
package net.jpmchase.payroll.processor.service;

import net.jpmchase.payroll.processor.common.context.WorkflowContext;
import net.jpmchase.payroll.processor.model.Event;
import net.jpmchase.payroll.processor.model.MessageBody;
import net.jpmchase.payroll.processor.retry.RetryOutboxEntity;
import net.jpmchase.payroll.processor.registry.WorkFlowRegistry;
import net.jpmchase.payroll.processor.service.SafService.SafMode;
import net.jpmchase.payroll.processor.service.SafTemplateProvider.SafDecision;
import net.jpmchase.payroll.processor.service.RetryScheduleService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.*;

import static net.jpmchase.payroll.processor.service.SafService.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

/**
 * Unit tests for SafService.
 * Focus:
 *  - seed(event, ctx)
 *  - shouldExecute(stepName, event, ctx)
 */
@ExtendWith(MockitoExtension.class)
class SafServiceTest {

    @Mock
    private WorkFlowRegistry workFlowRegistry;

    @Mock
    private SafTemplateProvider safTemplateProvider;

    @Mock
    private RetryScheduleService retryScheduleService;

    @InjectMocks
    private SafService safService;

    private Event event;
    private WorkflowContext ctx;
    private MessageBody body;

    @BeforeEach
    void setup() {
        // Build a minimal Event + MessageBody like processor actually sees.
        body = new MessageBody();
        body.setEntityType("Payroll");
        body.setEventType("payroll.processed");
        body.setEventId(UUID.randomUUID().toString());
        body.setResourceUUID(UUID.randomUUID());

        // headers map is what SafUtil.isSafEnabled(event) reads.
        Map<String, String> headers = new HashMap<>();
        // default to SAF ON unless overridden in each test
        headers.put("x-saf", "true");

        event = new Event();
        event.setMessageBody(body);
        event.setHeaders(headers);

        ctx = new WorkflowContext();
    }

    /* ------------------------- seed(...) tests ------------------------- */

    @Test
    void seed_whenSafDisabled_setsFlagAndReturnsEarly() {
        // given SAF header false
        event.getHeaders().put("x-saf", "false");

        // when
        safService.seed(event, ctx);

        // then
        // SAF_ENABLED=false and nothing else in context
        assertThat(ctx.get(SAF_ENABLED)).isEqualTo(Boolean.FALSE);
        assertThat(ctx.get(SAF_MODE)).isNull();
        assertThat(ctx.get(SAF_TARGET)).isNull();
        assertThat(ctx.get(SAF_SKIP_UNTIL)).isNull();
        assertThat(ctx.get(SAF_SKIP_SET)).isNull();
        assertThat(ctx.get(SAF_INCLUDE_SET)).isNull();

        // and we never hit DB/template
        verifyNoInteractions(retryScheduleService, safTemplateProvider);
    }

    @Test
    void seed_whenSafEnabled_butNoRetryOutboxRow_setsEnabledAndExits() {
        // SAF header already true from @BeforeEach
        // retryScheduleService returns empty
        when(retryScheduleService.getFailedStepFromRetryOutbox(anyString()))
            .thenReturn(Optional.empty());

        safService.seed(event, ctx);

        assertThat(ctx.get(SAF_ENABLED)).isEqualTo(Boolean.TRUE);

        // no SAF metadata added because we couldn't resolve failed step
        assertThat(ctx.get(SAF_MODE)).isNull();
        assertThat(ctx.get(SAF_TARGET)).isNull();
        assertThat(ctx.get(SAF_SKIP_UNTIL)).isNull();
        assertThat(ctx.get(SAF_SKIP_SET)).isNull();
        assertThat(ctx.get(SAF_INCLUDE_SET)).isNull();

        verify(retryScheduleService).getFailedStepFromRetryOutbox(body.getEventId());
        verifyNoInteractions(safTemplateProvider);
    }

    @Test
    void seed_whenTemplateDisabled_doesNotPopulatePolicy() {
        // given retryOutbox row found
        RetryOutboxEntity row = new RetryOutboxEntity();
        row.setStepName("PersistPayrollHierarchyToDatabase");
        when(retryScheduleService.getFailedStepFromRetryOutbox(anyString()))
            .thenReturn(Optional.of(row));

        // but template returned is disabled
        SafDecision disabledDecision = mock(SafDecision.class);
        when(disabledDecision.isEnabled()).thenReturn(false);
        when(safTemplateProvider.getTemplate(
                eq("Payroll"),
                eq("payroll.processed"),
                eq("PersistPayrollHierarchyToDatabase")))
            .thenReturn(disabledDecision);

        safService.seed(event, ctx);

        // SAF_ENABLED true, but nothing else because decision disabled
        assertThat(ctx.get(SAF_ENABLED)).isEqualTo(Boolean.TRUE);
        assertThat(ctx.get(SAF_MODE)).isNull();
        assertThat(ctx.get(SAF_TARGET)).isNull();
        assertThat(ctx.get(SAF_SKIP_UNTIL)).isNull();
        assertThat(ctx.get(SAF_SKIP_SET)).isNull();
        assertThat(ctx.get(SAF_INCLUDE_SET)).isNull();
    }

    @Test
    void seed_whenTemplateEnabled_populatesAllContextKeys() {
        // given retryOutbox row w/ failed step
        RetryOutboxEntity row = new RetryOutboxEntity();
        row.setStepName("PersistPayrollHierarchyToDatabase");
        when(retryScheduleService.getFailedStepFromRetryOutbox(anyString()))
            .thenReturn(Optional.of(row));

        // and SAF template decision is enabled
        SafDecision decision = mock(SafDecision.class);
        when(decision.isEnabled()).thenReturn(true);
        when(decision.getStartPolicy()).thenReturn(SafMode.RETRY_FROM_FAILED); // enum
        when(decision.getTargetStep()).thenReturn("PersistPayrollHierarchyToDatabase");
        when(decision.getSkipUntilStep()).thenReturn("GeneratePIMIdentifier");
        when(decision.getSkipSteps()).thenReturn(List.of("GeneratePIMIdentifier", "PersistPayrollHierarchyToDatabase"));
        when(decision.getIncludeSteps()).thenReturn(List.of("GustoDisbursementReconciliationForPayroll"));

        when(safTemplateProvider.getTemplate(
                eq("Payroll"),
                eq("payroll.processed"),
                eq("PersistPayrollHierarchyToDatabase")))
            .thenReturn(decision);

        safService.seed(event, ctx);

        assertThat(ctx.get(SAF_ENABLED)).isEqualTo(Boolean.TRUE);
        assertThat(ctx.get(SAF_MODE)).isEqualTo(SafMode.RETRY_FROM_FAILED.name());
        assertThat(ctx.get(SAF_TARGET)).isEqualTo("PersistPayrollHierarchyToDatabase");
        assertThat(ctx.get(SAF_SKIP_UNTIL)).isEqualTo("GeneratePIMIdentifier");

        // skip list and include list are stored as comma-separated strings
        assertThat(ctx.get(SAF_SKIP_SET)).isEqualTo(
            "GeneratePIMIdentifier,PersistPayrollHierarchyToDatabase"
        );
        assertThat(ctx.get(SAF_INCLUDE_SET)).isEqualTo(
            "GustoDisbursementReconciliationForPayroll"
        );
    }

    /* ------------------------- shouldExecute(...) tests ------------------------- */

    @Test
    void shouldExecute_whenSafDisabled_returnsTrue() {
        // SAF not enabled in ctx
        ctx.put(SAF_ENABLED, Boolean.FALSE);

        boolean result = safService.shouldExecute("AnyStep", event, ctx);

        assertThat(result).isTrue();
    }

    @Test
    void shouldExecute_retryFromFailed_honorsIncludeSteps() {
        // SAF enabled
        ctx.put(SAF_ENABLED, Boolean.TRUE);
        ctx.put(SAF_MODE, SafMode.RETRY_FROM_FAILED.name());
        ctx.put(SAF_INCLUDE_SET, "StepA,StepB"); // only these allowed
        ctx.put(SAF_TARGET, "DoesNotMatterHere");

        boolean execA = safService.shouldExecute("StepA", event, ctx);
        boolean execX = safService.shouldExecute("StepX", event, ctx);

        assertThat(execA).isTrue();   // included
        assertThat(execX).isFalse();  // not included
    }

    @Test
    void shouldExecute_retryFromFailed_afterTargetStepOrdering() {
        // SAF enabled, no include list
        ctx.put(SAF_ENABLED, Boolean.TRUE);
        ctx.put(SAF_MODE, SafMode.RETRY_FROM_FAILED.name());
        ctx.put(SAF_TARGET, "Step2");

        // workflow order returned by registry
        when(workFlowRegistry.getOrderedStepNames("Payroll","payroll.processed"))
            .thenReturn(List.of("Step1","Step2","Step3","Step4"));

        boolean exec1 = safService.shouldExecute("Step1", event, ctx); // before pivot
        boolean exec2 = safService.shouldExecute("Step2", event, ctx); // pivot
        boolean exec3 = safService.shouldExecute("Step3", event, ctx); // after pivot

        assertThat(exec1).isFalse();
        assertThat(exec2).isTrue();
        assertThat(exec3).isTrue();
    }

    @Test
    void shouldExecute_startWithSkip_skipsNamedAndBeforeSkipUntil() {
        // SAF enabled
        ctx.put(SAF_ENABLED, Boolean.TRUE);
        ctx.put(SAF_MODE, SafMode.START_WITH_SKIP.name());
        ctx.put(SAF_SKIP_UNTIL, "Step3");
        ctx.put(SAF_SKIP_SET, "StepX,StepY");

        when(workFlowRegistry.getOrderedStepNames("Payroll","payroll.processed"))
            .thenReturn(List.of("Step1","Step2","Step3","Step4","StepX","StepY"));

        boolean execStep1 = safService.shouldExecute("Step1", event, ctx); // before Step3
        boolean execStep3 = safService.shouldExecute("Step3", event, ctx); // pivot or after
        boolean execSkipX = safService.shouldExecute("StepX", event, ctx); // explicitly skipped

        assertThat(execStep1).isFalse();   // before pivot -> false
        assertThat(execStep3).isTrue();    // pivot and after -> true
        assertThat(execSkipX).isFalse();   // explicit skip list wins
    }

    @Test
    void shouldExecute_defaultMode_returnsTrue() {
        // SAF enabled but mode not matched (e.g. START_FROM_FIRST)
        ctx.put(SAF_ENABLED, Boolean.TRUE);
        ctx.put(SAF_MODE, SafMode.START_FROM_FIRST.name());

        boolean exec = safService.shouldExecute("Whatever", event, ctx);

        assertThat(exec).isTrue();
    }
}

package net.jpmchase.payroll.processor.conditions.payroll;

import net.jpmchase.payroll.processor.common.context.WorkflowContext;
import net.jpmchase.payroll.processor.remote.pim.model.TransactionIdentifiers;
import net.jpmchase.payroll.processor.repository.mgmt.entity.contractor.payment.ContractorPaymentEntity;
import net.jpmchase.payroll.processor.repository.mgmt.entity.contractor.payment.ContractorPaymentGroupEntity;
import net.jpmchase.payroll.processor.repository.mgmt.entity.contractor.payment.ContractorPaymentId;
import net.jpmchase.payroll.processor.service.ContractorPaymentService;
import net.jpmchase.payroll.processor.utils.AppConstants;
import net.jpmchase.payroll.processor.utils.PaymentTypeUtil;
import org.junit.jupiter.api.*;
import org.mockito.MockedStatic;

import java.lang.reflect.Method;
import java.util.*;

import static net.jpmchase.payroll.processor.utils.WorkflowContextUtil.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class PaymentPIMIdentifierMissingConditionTest {

    private ContractorPaymentService contractorPaymentService;
    private PaymentPIMIdentifierMissingCondition condition;
    private WorkflowContext context;

    @BeforeEach
    void setup() {
        contractorPaymentService = mock(ContractorPaymentService.class);
        condition = new PaymentPIMIdentifierMissingCondition(contractorPaymentService);
        context = new WorkflowContext();
    }

    @AfterEach
    void tearDown() {
        // Defensive: clears any inline/static mocks in case a test bails early
        org.mockito.Mockito.framework().clearInlineMocks();
    }

    @Test
    void testEvaluate_PaymentPinIdentifierNull_ReturnsTrue() {
        ContractorPaymentGroupEntity group = mock(ContractorPaymentGroupEntity.class);
        when(group.getSrcCntrPymtGrpId()).thenReturn(null);

        context.put(GROUP_PAYMENT_ENTITY, group);

        assertTrue(condition.evaluate(context));
        assertNull(context.get(TRANSACTION_IDENTIFIER_LIST, List.class));
    }

    @Test
    void testEvaluate_ValidPinIdentifier_NoPayments_ReturnsFalseAndTxnIdsNull() {
        ContractorPaymentGroupEntity group = mock(ContractorPaymentGroupEntity.class);
        when(group.getSrcCntrPymtGrpId()).thenReturn("PIM123");
        context.put(GROUP_PAYMENT_ENTITY, group);

        when(contractorPaymentService.getContractorPaymentsForGroupId("GROUP1"))
                .thenReturn(Collections.emptyList());
        context.put(GROUP_PAYMENT_ID, "GROUP1");

        try (MockedStatic<PaymentTypeUtil> mocked = mockStatic(PaymentTypeUtil.class)) {
            mocked.when(() -> PaymentTypeUtil.isNotCheckPaymentType("ACH")).thenReturn(true);

            boolean result = condition.evaluate(context);
            assertFalse(result);
            assertNull(context.get(TRANSACTION_IDENTIFIER_LIST, List.class));
        }
    }

    @Test
    void testEvaluate_ValidPinIdentifier_PaymentsWithNoTxnIds_ReturnsFalseAndTransactionIdentifiersNull() {
        ContractorPaymentGroupEntity group = mock(ContractorPaymentGroupEntity.class);
        when(group.getSrcCntrPymtGrpId()).thenReturn("PIM123");
        context.put(GROUP_PAYMENT_ENTITY, group);

        // Two ACH payments but no instrument detail IDs
        ContractorPaymentId debitId = mock(ContractorPaymentId.class);
        when(debitId.getDrCrCd()).thenReturn(AppConstants.TXN_DEBIT_CD);
        ContractorPaymentEntity debit = mock(ContractorPaymentEntity.class);
        when(debit.getTxnModeCd()).thenReturn("ACH");
        when(debit.getId()).thenReturn(debitId);
        when(debit.getSrcPymtInstrDtlId()).thenReturn(null);

        ContractorPaymentId creditId = mock(ContractorPaymentId.class);
        when(creditId.getDrCrCd()).thenReturn(AppConstants.TXN_CREDIT_CD);
        ContractorPaymentEntity credit = mock(ContractorPaymentEntity.class);
        when(credit.getTxnModeCd()).thenReturn("ACH");
        when(credit.getId()).thenReturn(creditId);
        when(credit.getSrcPymtInstrDtlId()).thenReturn(null);

        when(contractorPaymentService.getContractorPaymentsForGroupId("GROUP1"))
                .thenReturn(List.of(debit, credit));
        context.put(GROUP_PAYMENT_ID, "GROUP1");

        try (MockedStatic<PaymentTypeUtil> mocked = mockStatic(PaymentTypeUtil.class)) {
            mocked.when(() -> PaymentTypeUtil.isNotCheckPaymentType("ACH")).thenReturn(true);

            boolean result = condition.evaluate(context);
            assertFalse(result);
            assertNull(context.get(TRANSACTION_IDENTIFIER_LIST, List.class));
        }
    }

    @Test
    void testEvaluate_ValidPinIdentifier_PaymentsWithDebitAndCreditTxnIds_ReturnsFalseAndTransactionIdentifiersPopulated() {
        ContractorPaymentGroupEntity group = mock(ContractorPaymentGroupEntity.class);
        when(group.getSrcCntrPymtGrpId()).thenReturn("PIM123");
        context.put(GROUP_PAYMENT_ENTITY, group);

        // Debit with ID
        ContractorPaymentId debitId = mock(ContractorPaymentId.class);
        when(debitId.getDrCrCd()).thenReturn(AppConstants.TXN_DEBIT_CD);
        ContractorPaymentEntity debit = mock(ContractorPaymentEntity.class);
        when(debit.getTxnModeCd()).thenReturn("ACH");
        when(debit.getId()).thenReturn(debitId);
        when(debit.getSrcPymtInstrDtlId()).thenReturn("DEBIT_TXN_1");

        // Credit with ID
        ContractorPaymentId creditId = mock(ContractorPaymentId.class);
        when(creditId.getDrCrCd()).thenReturn(AppConstants.TXN_CREDIT_CD);
        ContractorPaymentEntity credit = mock(ContractorPaymentEntity.class);
        when(credit.getTxnModeCd()).thenReturn("ACH");
        when(credit.getId()).thenReturn(creditId);
        when(credit.getSrcPymtInstrDtlId()).thenReturn("CREDIT_TXN_1");

        when(contractorPaymentService.getContractorPaymentsForGroupId("GROUP1"))
                .thenReturn(List.of(debit, credit));
        context.put(GROUP_PAYMENT_ID, "GROUP1");

        try (MockedStatic<PaymentTypeUtil> mocked = mockStatic(PaymentTypeUtil.class)) {
            mocked.when(() -> PaymentTypeUtil.isNotCheckPaymentType("ACH")).thenReturn(true);

            boolean result = condition.evaluate(context);
            assertFalse(result);

            @SuppressWarnings("unchecked")
            List<TransactionIdentifiers> list =
                    context.get(TRANSACTION_IDENTIFIER_LIST, List.class);
            assertNotNull(list);
            assertEquals(1, list.size());
            TransactionIdentifiers ti = list.get(0);

            assertEquals("PIM123", ti.getTransactionIdentifier());
            assertEquals(List.of("DEBIT_TXN_1"), ti.getDebitTransactionIdentifiers());
            assertEquals(List.of("CREDIT_TXN_1"), ti.getCreditTransactionIdentifiers());
            assertEquals(1, ti.getDebitRecordCount());
            assertEquals(1, ti.getCreditRecordCount());
        }
    }

    // --- Private-method coverage (reflection) ---

    @Test
    void testExtractTransactionIds_EntitiesNull_ReturnsEmptyList() throws Exception {
        List<String> ids = invokeExtractTransactionIds(null, AppConstants.TXN_DEBIT_CD);
        assertTrue(ids.isEmpty());
    }

    @Test
    void testExtractTransactionIds_EntitiesWithNullOrEmptyTxnId_FilteredOut() throws Exception {
        ContractorPaymentId id = mock(ContractorPaymentId.class);
        when(id.getDrCrCd()).thenReturn(AppConstants.TXN_DEBIT_CD);

        ContractorPaymentEntity e1 = mock(ContractorPaymentEntity.class);
        when(e1.getTxnModeCd()).thenReturn("ACH");
        when(e1.getId()).thenReturn(id);
        when(e1.getSrcPymtInstrDtlId()).thenReturn(null);

        ContractorPaymentEntity e2 = mock(ContractorPaymentEntity.class);
        when(e2.getTxnModeCd()).thenReturn("ACH");
        when(e2.getId()).thenReturn(id);
        when(e2.getSrcPymtInstrDtlId()).thenReturn("");

        try (MockedStatic<PaymentTypeUtil> mocked = mockStatic(PaymentTypeUtil.class)) {
            mocked.when(() -> PaymentTypeUtil.isNotCheckPaymentType("ACH")).thenReturn(true);
            List<String> ids = invokeExtractTransactionIds(List.of(e1, e2), AppConstants.TXN_DEBIT_CD);
            assertTrue(ids.isEmpty());
        }
    }

    // -------- helpers --------

    @SuppressWarnings("unchecked")
    private List<String> invokeExtractTransactionIds(List<ContractorPaymentEntity> entities, char drCr)
            throws Exception {
        Method m = PaymentPIMIdentifierMissingCondition.class
                .getDeclaredMethod("extractTransactionIds", List.class, Character.TYPE);
        m.setAccessible(true);
        return (List<String>) m.invoke(condition, entities, drCr);
    }
}
