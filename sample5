// package net.jpmchase.payroll.recon.kafka;

@Slf4j
@Service
@RequiredArgsConstructor
public class SafProducerService {

  private final KafkaTemplate<String, Object> kafkaTemplate;

  @Value("${payroll.topic}")         private String topic;
  @Value("${recon.replay-event-type}")     private String replayEventType;
  @Value("${recon.cancel-event-type}")     private String cancelEventType;
  @Value("${recon.reconcile-event-type}")  private String reconcileEventType;

  public void publishReplay(String companyId, String entityId, String entityType,
                            String failedStep, String retryId, int attempt) {
    String eventId = UUID.randomUUID().toString();

    var event = PayrollManagementProcessingEventReceived.newBuilder()
        .setEventIdentifier(eventId)
        .setEventProcessTimestamp(System.currentTimeMillis())
        .setEventTypeName(replayEventType)
        .setEntityTypeName(entityType)
        .setEntityIdentifier(entityId)
        .setResourceTypeName("Company")
        .setResourceIdentifier(companyId)
        .build();

    var record = new ProducerRecord<String, Object>(topic, companyId, event);
    header(record, "x-publisher", "RECON_MANAGER");
    header(record, "x-saf", "true");
    header(record, "x-idempotency-key", IdempotencyKeys.replay(retryId));
    header(record, "x-retry-attempt", Integer.toString(attempt));
    if (failedStep != null) header(record, "x-failed-step", failedStep);

    kafkaTemplate.send(record);
    log.info("[RECON] REPLAY published company={} retryId={} step={} attempt={}",
        companyId, retryId, failedStep, attempt);
  }

  public void publishCancel(String companyId, String entityType, String entityId, String reason) {
    String eventId = "cxl-" + UUID.randomUUID();

    var event = PayrollManagementProcessingEventReceived.newBuilder()
        .setEventIdentifier(eventId)
        .setEventProcessTimestamp(System.currentTimeMillis())
        .setEventTypeName(cancelEventType)
        .setEntityTypeName(entityType)
        .setEntityIdentifier(entityId)
        .setResourceTypeName("Company")
        .setResourceIdentifier(companyId)
        .build();

    var record = new ProducerRecord<String, Object>(topic, companyId, event);
    header(record, "x-publisher", "RECON_MANAGER");
    header(record, "x-idempotency-key", IdempotencyKeys.cancel(entityType, entityId));
    if (reason != null) header(record, "x-reason", reason);

    kafkaTemplate.send(record);
    log.info("[RECON] CANCEL published company={} entity={}/{} reason={}", companyId, entityType, entityId, reason);
  }

  public void publishReconcile(String batchId) {
    String eventId = "recon-" + UUID.randomUUID();

    var event = PayrollManagementProcessingEventReceived.newBuilder()
        .setEventIdentifier(eventId)
        .setEventProcessTimestamp(System.currentTimeMillis())
        .setEventTypeName(reconcileEventType)
        .setEntityTypeName("Payroll")
        .setEntityIdentifier("all")
        .setResourceTypeName("Company")
        .setResourceIdentifier("all")
        .build();

    var record = new ProducerRecord<String, Object>(topic, "all", event);
    header(record, "x-publisher", "JOB");
    header(record, "x-idempotency-key", "RECONCILE:" + batchId);
    header(record, "x-batch-id", batchId);

    kafkaTemplate.send(record);
    log.info("[RECON] RECONCILE published batchId={}", batchId);
  }

  private static void header(ProducerRecord<String, Object> r, String k, String v) {
    r.headers().add(new RecordHeader(k, v.getBytes(StandardCharsets.UTF_8)));
  }
}
// package net.jpmchase.payroll.recon.support;
public final class IdempotencyKeys {
  private IdempotencyKeys(){}
  public static String replay(String retryId) { return "REPLAY:" + (retryId == null ? "" : retryId); }
  public static String cancel(String entityType, String entityId) { return "CANCEL:" + nz(entityType) + ":" + nz(entityId); }
  private static String nz(String s){ return s == null ? "" : s; }
}
// package net.jpmchase.payroll.recon.scheduler;

@Slf4j
@Service
@RequiredArgsConstructor
@ConditionalOnProperty(prefix = "recon.scheduler", name = "enabled", havingValue = "true", matchIfMissing = true)
public class ReconRetryScheduler {

  private final ReconOutboxRepository repo;
  private final SafProducerService producer;

  @Value("${recon.batch-size:500}")    private int batchSize;
  @Value("${recon.max-retry-count:3}") private int maxRetries;
  @Value("${recon.lease-seconds:300}") private int leaseSeconds;

  @Scheduled(fixedDelayString = "${recon.scheduler.fixed-delay-ms:300000}")
  @SchedulerLock(name = "ReconRetryScheduler.run", lockAtLeastFor = "PT1M", lockAtMostFor = "PT4M30S")
  public void run() {
    log.info("[RECON] cycle start");

    var replays = repo.claimReplayBatch(maxRetries, batchSize, leaseSeconds);
    for (var r : replays) {
      try {
        producer.publishReplay(
            r.getSourceCompanyId(),
            r.getEntityId(),
            r.getEntityTypeName(),
            r.getStepName(),
            r.getRetryId(),
            r.getRetryCount() + 1);
        repo.markSent(r.getRetryId(), "replay published");
      } catch (Exception e) {
        log.error("[RECON] publish replay failed retryId={} company={} step={}",
            r.getRetryId(), r.getSourceCompanyId(), r.getStepName(), e);
        repo.markPublishFailed(r.getRetryId(), firstLine(e));
      }
    }

    var cancels = repo.claimCancelBatch(maxRetries, batchSize);
    for (var r : cancels) {
      try {
        var reason = (r.getExpiryTs() != null && r.getExpiryTs().isBefore(Instant.now()))
            ? "retry_expired" : "max_retries_exhausted";
        producer.publishCancel(r.getSourceCompanyId(), r.getEntityTypeName(), r.getEntityId(), reason);
        repo.markCancelSent(r.getRetryId(), "cancel published");
      } catch (Exception e) {
        log.error("[RECON] publish cancel failed retryId={} company={} entity={}",
            r.getRetryId(), r.getSourceCompanyId(), r.getEntityId(), e);
        repo.markPublishFailed(r.getRetryId(), firstLine(e));
      }
    }

    log.info("[RECON] cycle end — replays={} cancels={}", replays.size(), cancels.size());
  }

  private static String firstLine(Exception e) {
    String m = e.getMessage();
    return (m == null) ? e.getClass().getSimpleName() : m.split("\\R", 2)[0];
  }
}

// package net.jpmchase.payroll.processor.adapters;
@Service
@RequiredArgsConstructor
public class SafCompletionPublisherHook {

  private final ReconOutboxRepository reconRepo;

  public void onSuccessfulSafProcessing(Headers headers) {
    var idem = header(headers, "x-idempotency-key");
    if (idem != null && idem.startsWith("REPLAY:")) {
      var retryId = idem.substring("REPLAY:".length());
      if (!retryId.isBlank()) reconRepo.markProcessed(retryId);
    }
  }

  private static String header(Headers h, String key) {
    var it = h.headers(key).iterator();
    return it.hasNext() ? new String(it.next().value(), StandardCharsets.UTF_8) : null;
  }
}

// package net.jpmchase.payroll.recon.outbox;

public interface ReconOutboxRepository extends JpaRepository<RetryOutboxRow, String> {

  // Claim replay rows: FAILED, under maxRetries, not expired, lease elapsed
  @Modifying
  @Query(value = """
    WITH c AS (
      SELECT pyrl_rtry_id
        FROM pyrl_rtry_outbox
       WHERE sts_cd = 0
         AND rtry_cn < :maxRetries
         AND (expr_ts IS NULL OR expr_ts > NOW())
         AND (updt_ts IS NULL OR updt_ts < NOW() - (:leaseSeconds || ' seconds')::interval)
       ORDER BY cre_ts
       FOR UPDATE SKIP LOCKED
       LIMIT :batchSize
    )
    UPDATE pyrl_rtry_outbox r
       SET sts_cd = 1,
           updt_ts = NOW(),
           sts_rsn_tx = 'claimed for replay'
     WHERE r.pyrl_rtry_id IN (SELECT pyrl_rtry_id FROM c)
     RETURNING r.*;
  """, nativeQuery = true)
  List<RetryOutboxRow> claimReplayBatch(@Param("maxRetries") int maxRetries,
                                        @Param("batchSize") int batchSize,
                                        @Param("leaseSeconds") int leaseSeconds);

  // Claim cancel rows: FAILED and exhausted or expired
  @Modifying
  @Query(value = """
    WITH c AS (
      SELECT pyrl_rtry_id
        FROM pyrl_rtry_outbox
       WHERE sts_cd = 0
         AND (rtry_cn >= :maxRetries OR (expr_ts IS NOT NULL AND expr_ts <= NOW()))
       ORDER BY cre_ts
       FOR UPDATE SKIP LOCKED
       LIMIT :batchSize
    )
    UPDATE pyrl_rtry_outbox r
       SET sts_cd = 1,
           updt_ts = NOW(),
           sts_rsn_tx = 'claimed for cancel'
     WHERE r.pyrl_rtry_id IN (SELECT pyrl_rtry_id FROM c)
     RETURNING r.*;
  """, nativeQuery = true)
  List<RetryOutboxRow> claimCancelBatch(@Param("maxRetries") int maxRetries,
                                        @Param("batchSize") int batchSize);

  // Mark publish success (REPLAY → SENT)
  @Modifying
  @Query(value = """
    UPDATE pyrl_rtry_outbox
       SET sts_cd = 2,
           rtry_cn = rtry_cn + 1,
           updt_ts = NOW(),
           sts_rsn_tx = :reason
     WHERE pyrl_rtry_id = :retryId
  """, nativeQuery = true)
  int markSent(@Param("retryId") String retryId, @Param("reason") String reason);

  // Mark publish failed (back to FAILED, bump count)
  @Modifying
  @Query(value = """
    UPDATE pyrl_rtry_outbox
       SET sts_cd = 0,
           rtry_cn = rtry_cn + 1,
           updt_ts = NOW(),
           sts_rsn_tx = :error
     WHERE pyrl_rtry_id = :retryId
  """, nativeQuery = true)
  int markPublishFailed(@Param("retryId") String retryId, @Param("error") String error);

  // Mark cancel sent
  @Modifying
  @Query(value = """
    UPDATE pyrl_rtry_outbox
       SET sts_cd = 3,
           rtry_cn = rtry_cn + 1,
           updt_ts = NOW(),
           sts_rsn_tx = :reason
     WHERE pyrl_rtry_id = :retryId
  """, nativeQuery = true)
  int markCancelSent(@Param("retryId") String retryId, @Param("reason") String reason);

  // Mark processed (called by Processor on success)
  @Modifying
  @Query(value = """
    UPDATE pyrl_rtry_outbox
       SET sts_cd = 4,
           updt_ts = NOW(),
           sts_rsn_tx = 'processor completed'
     WHERE pyrl_rtry_id = :retryId
  """, nativeQuery = true)
  int markProcessed(@Param("retryId") String retryId);
}
