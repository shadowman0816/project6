package com.yourcompany.payroll.config;

import java.time.Duration;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.kafka.ConcurrentKafkaListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;

@Configuration
public class KafkaAuthRetryConfig {

    @Value("${kafka.auth-exception-retry-interval-seconds:60}")
    private long interval;

    @Bean
    @ConditionalOnMissingBean(ConcurrentKafkaListenerContainerFactory.class)
    public ConcurrentKafkaListenerContainerFactory<Object, Object> defaultFactory(
            ConcurrentKafkaListenerContainerFactoryConfigurer configurer,
            ConsumerFactory<Object, Object> consumerFactory) {

        ConcurrentKafkaListenerContainerFactory<Object, Object> factory =
                new ConcurrentKafkaListenerContainerFactory<>();

        configurer.configure(factory, consumerFactory);

        return factory;
    }

    @Bean
    public BeanPostProcessor kafkaFactoryPostProcessor() {
        return new BeanPostProcessor() {

            @Override
            public Object postProcessAfterInitialization(Object bean, String beanName)
                    throws BeansException {

                if (bean instanceof ConcurrentKafkaListenerContainerFactory<?, ?> factory) {

                    factory.setContainerCustomizer(container ->
                            container.getContainerProperties()
                                     .setAuthExceptionRetryInterval(
                                             Duration.ofSeconds(interval)
                                     ));
                }

                return bean;
            }
        };
    }
}

package net.jpmchase.payroll.processor.common.config;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.time.Duration;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.boot.autoconfigure.kafka.ConcurrentKafkaListenerContainerFactoryConfigurer;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.test.util.ReflectionTestUtils;

public class KsaasContainerConfigTest {

    @Test
    void defaultFactory_shouldCreateFactoryAndInvokeConfigurer() {
        // Arrange
        KsaasContainerConfig config = new KsaasContainerConfig();

        @SuppressWarnings("unchecked")
        ConcurrentKafkaListenerContainerFactoryConfigurer configurer =
                mock(ConcurrentKafkaListenerContainerFactoryConfigurer.class);

        @SuppressWarnings("unchecked")
        ConsumerFactory<Object, Object> consumerFactory =
                mock(ConsumerFactory.class);

        // Act
        ConcurrentKafkaListenerContainerFactory<Object, Object> factory =
                config.defaultFactory(configurer, consumerFactory);

        // Assert
        assertNotNull(factory, "Factory must not be null");
        verify(configurer, times(1)).configure(factory, consumerFactory);
        verifyNoMoreInteractions(configurer);
    }

    @Test
    void kafkaFactoryPostProcessor_shouldSetContainerCustomizerOnKafkaFactories() {
        // Arrange
        KsaasContainerConfig config = new KsaasContainerConfig();
        long expectedSeconds = 42L;
        // Set the private @Value field manually for the test
        ReflectionTestUtils.setField(
                config,
                "authExceptionRetryIntervalSeconds",
                expectedSeconds
        );

        BeanPostProcessor postProcessor = config.kafkaFactoryPostProcessor();

        @SuppressWarnings("unchecked")
        ConcurrentKafkaListenerContainerFactory<Object, Object> factory =
                spy(new ConcurrentKafkaListenerContainerFactory<>());

        // Act
        Object result = postProcessor.postProcessAfterInitialization(factory, "kafkaListenerContainerFactory");

        // Assert
        // The bean itself must be returned
        org.junit.jupiter.api.Assertions.assertNotNull(result);
        org.junit.jupiter.api.Assertions.assertSame(factory, result);

        // Verify that setContainerCustomizer was called with some lambda
        verify(factory, times(1)).setContainerCustomizer(any());

        // Optional: verify that the lambda uses the configured seconds value.
        // We capture the argument and invoke it against a real container instance.
        @SuppressWarnings("unchecked")
        var customizerCaptor =
                org.mockito.ArgumentCaptor.forClass(
                        org.springframework.kafka.config.ContainerCustomizer.class);

        verify(factory).setContainerCustomizer(customizerCaptor.capture());

        var customizer = customizerCaptor.getValue();
        // Build a minimal container to apply the customizer to
        var containerProps = new org.springframework.kafka.listener.ContainerProperties("dummy-topic");
        var consumerFactory = mock(ConsumerFactory.class);
        var container =
                new org.springframework.kafka.listener.ConcurrentMessageListenerContainer<>(
                        consumerFactory, containerProps);

        // Act: apply the customizer
        //noinspection unchecked
        customizer.configure(container);

        Duration actual = container.getContainerProperties().getAuthExceptionRetryInterval();
        org.junit.jupiter.api.Assertions.assertEquals(
                Duration.ofSeconds(expectedSeconds),
                actual,
                "Auth exception retry interval must match configured seconds"
        );
    }

    @Test
    void kafkaFactoryPostProcessor_shouldIgnoreNonFactoryBeans() {
        // Arrange
        KsaasContainerConfig config = new KsaasContainerConfig();
        ReflectionTestUtils.setField(config,
                "authExceptionRetryIntervalSeconds",
                30L);

        BeanPostProcessor postProcessor = config.kafkaFactoryPostProcessor();

        Object someOtherBean = new Object();

        // Act
        Object result = postProcessor.postProcessAfterInitialization(someOtherBean, "someOtherBean");

        // Assert: bean is returned unchanged and no exceptions are thrown
        org.junit.jupiter.api.Assertions.assertSame(someOtherBean, result);
    }
}
@Service
@RequiredArgsConstructor
@Slf4j
public class RetryScheduleService {

    private static final ZoneId EASTERN_TIMEZONE_ID = ZoneId.of("America/New_York");
    private static final LocalTime FUTURE_DUE_DATE_EXPIRY_TIME = LocalTime.of(15, 0); // 3 PM
    private static final String DELIVERY_DUE_DATE_CTX_KEY = "DELIVERY_DUE_DATE"; // TODO: use your real key

    private final RetryOutboxRepository retryOutboxRepository;

    // ... existing scheduleRetry(...) and saveRetry(...)

    /**
     * For future-dated payrolls:
     *  - If deliveryDueDate > today (Eastern), expiry = deliveryDueDate @ 15:00 Eastern
     * For all other cases:
     *  - expiry = current backoff logic (cutoff/maxBackoffHours).
     */
    private Timestamp getExpiryTimestamp(final StepConfig stepConfig,
                                         final WorkflowContext context) {

        // Try to read delivery due date from context (assuming LocalDate; adjust if String)
        LocalDate deliveryDueDate = null;
        try {
            deliveryDueDate = context.get(DELIVERY_DUE_DATE_CTX_KEY, LocalDate.class);
        } catch (Exception ignore) {
            // If you're storing it as String instead, uncomment this:
            // String dateStr = context.get(DELIVERY_DUE_DATE_CTX_KEY, String.class);
            // if (StringUtils.isNotBlank(dateStr)) {
            //     deliveryDueDate = LocalDate.parse(dateStr);
            // }
        }

        ZonedDateTime nowEastern = ZonedDateTime.now(EASTERN_TIMEZONE_ID);
        LocalDate todayEastern = nowEastern.toLocalDate();

        if (deliveryDueDate != null && deliveryDueDate.isAfter(todayEastern)) {
            // Future-dated payroll ⇒ expiry at 3 PM Eastern on delivery date
            ZonedDateTime expiryEastern =
                    ZonedDateTime.of(deliveryDueDate, FUTURE_DUE_DATE_EXPIRY_TIME, EASTERN_TIMEZONE_ID);
            return Timestamp.from(expiryEastern.toInstant());
        }

        // Same-day or past-dated ⇒ use existing backoff logic
        return getEffectiveBackOffTime(stepConfig);
    }

    /**
     * Existing method – unchanged.
     * Keeps your "maxBackoffHours vs cutoffTime" behaviour.
     */
    private Timestamp getEffectiveBackOffTime(final StepConfig stepConfig) {
        StepConfig.SafConfig safConfigs = stepConfig.getSafConfigs();
        LocalTime now = LocalTime.now();
        LocalTime maxBackOffTime = now.plusHours(safConfigs.getMaxBackOffHours());

        if (safConfigs.getCutoffTime() == null) {
            return Timestamp.from(
                    LocalDateTime.of(LocalDate.now(), maxBackOffTime)
                            .atZone(ZoneId.systemDefault())
                            .toInstant());
        }

        LocalTime cutoff = LocalTime.parse(safConfigs.getCutoffTime());
        LocalTime effectiveBackoffTime = maxBackOffTime.isAfter(cutoff) ? maxBackOffTime : cutoff;

        return Timestamp.from(
                LocalDateTime.of(LocalDate.now(), effectiveBackoffTime)
                        .atZone(ZoneId.systemDefault())
                        .toInstant());
    }
}

